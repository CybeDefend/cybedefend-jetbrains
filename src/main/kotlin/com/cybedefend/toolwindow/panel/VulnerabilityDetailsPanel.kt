package com.cybedefend.toolwindow.panel

import DetailedVulnerability
import GetProjectVulnerabilityByIdResponse
import GetProjectVulnerabilityByIdResponseDto
import VulnerabilityDtoResponse
import VulnerabilitySastDto
import VulnerabilitySastIacResponse
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.editor.markup.EffectType
import com.intellij.openapi.editor.markup.HighlighterLayer
import com.intellij.openapi.editor.markup.TextAttributes
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.ui.HyperlinkLabel
import com.intellij.ui.JBColor
import com.intellij.ui.components.JBLabel
import com.intellij.ui.components.JBPanel
import com.intellij.ui.components.JBScrollPane
import com.intellij.util.ui.FormBuilder
import com.intellij.util.ui.JBUI
import toUnified
import java.awt.BorderLayout
import java.awt.CardLayout
import java.awt.FlowLayout
import java.awt.Font
import java.awt.Graphics
import java.awt.Graphics2D
import java.awt.Color
import java.awt.Component
import java.awt.Dimension
import javax.swing.*
import javax.swing.event.HyperlinkEvent

/**
 * Panel that displays vulnerability details with:
 * - Header: severity badge, title, file link on separate line
 * - Description, shortDescription, howToPrevent
 * - Status, Priority, Time To Fix, File Hash
 * - Conditional sections: Context, Metadata, Data Flow, History, Code Snippets
 */
class VulnerabilityDetailsPanel(private val project: Project) : JBPanel<VulnerabilityDetailsPanel>(BorderLayout()) {
    private val cardLayout = CardLayout()
    private val emptyPanel = JBPanel<JBPanel<*>>(BorderLayout()).apply {
        add(
            JBLabel("No vulnerability selected", SwingConstants.CENTER)
                .apply { font = font.deriveFont(Font.ITALIC, 14f) }, BorderLayout.CENTER
        )
    }
    private val detailContainer = JBPanel<JBPanel<*>>(BorderLayout()).apply {
        border = JBUI.Borders.empty(16)
    }

    init {
        layout = cardLayout
        add(emptyPanel, "empty")
        add(JBScrollPane(detailContainer).apply {
            horizontalScrollBarPolicy = JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        }, "details")
        showPlaceholder()
    }

    fun showPlaceholder() {
        cardLayout.show(this, "empty")
    }

    fun showDetails(dto: GetProjectVulnerabilityByIdResponse) { // Nouvelle signature
        // 1. Extraire la vulnérabilité de base, peu importe son type
        val baseVulnerability = when {
            dto.sast != null -> dto.sast.toUnified()
            dto.iac != null -> dto.iac.toUnified()
            dto.sca != null -> dto.sca.toUnified()
            else -> {
                showPlaceholder()
                return
            }
        }

        // 2. Utiliser baseVulnerability partout
        detailContainer.removeAll()

        val header = JBPanel<JBPanel<*>>(BorderLayout()).apply {
            add(JBPanel<JBPanel<*>>(FlowLayout(FlowLayout.LEFT, 8, 0)).apply {
                add(JBLabel(SeverityBadgeIcon(baseVulnerability.currentSeverity))).also {
                    (it as JBLabel).toolTipText = baseVulnerability.currentSeverity
                }
                add(JBLabel(baseVulnerability.vulnerability.name).apply { // Corrigé
                    font = font.deriveFont(Font.BOLD, 22f)
                })
            }, BorderLayout.NORTH)
            add(JBPanel<JBPanel<*>>(FlowLayout(FlowLayout.LEFT)).apply {
                add(HyperlinkLabel(baseVulnerability.path).apply { // Corrigé
                    addHyperlinkListener { e ->
                        if (e.eventType == HyperlinkEvent.EventType.ACTIVATED) openFileAt(baseVulnerability) // Corrigé
                    }
                })
            }, BorderLayout.SOUTH)
            border = JBUI.Borders.emptyBottom(16)
        }
        detailContainer.add(header, BorderLayout.NORTH)

        val fb = FormBuilder.createFormBuilder()

        // Short description
        baseVulnerability.vulnerability.shortDescription.takeIf { it.isNotBlank() }?.let { // Corrigé
            fb.addComponent(JBLabel(it).apply {
                border = JBUI.Borders.empty(0, 0, 12, 0)
            })
        }
        // Description
        fb.addComponent(JBLabel("Description").apply { font = font.deriveFont(Font.BOLD, 14f) })
        fb.addComponent(createMarkdownPane(baseVulnerability.vulnerability.description)) // Corrigé

        // Prevention
        baseVulnerability.vulnerability.howToPrevent.takeIf { it.isNotBlank() }?.let { // Corrigé
            fb.addComponent(JBLabel("How to Prevent").apply {
                font = font.deriveFont(Font.BOLD, 14f)
                border = JBUI.Borders.empty(12, 0)
            })
            fb.addComponent(createMarkdownPane(it))
        }

        // Details
        fb.addComponent(JBLabel("Details").apply {
            font = font.deriveFont(Font.BOLD, 14f)
            border = JBUI.Borders.empty(12, 0)
        })
        fb.addLabeledComponent("State:", JBLabel(baseVulnerability.currentState)) // Corrigé
        fb.addLabeledComponent("Priority:", JBLabel(baseVulnerability.currentPriority)) // Corrigé
        baseVulnerability.timeToFix?.takeIf { it.isNotBlank() }?.let { // Corrigé
            fb.addLabeledComponent("Time To Fix:", JBLabel(it))
        }

        // Context
        baseVulnerability.contextualExplanation?.takeIf { it.isNotBlank() }?.let { ctx -> // Corrigé
            fb.addComponent(JBLabel("Context").apply {
                font = font.deriveFont(Font.BOLD, 14f)
                border = JBUI.Borders.empty(12, 0)
            })
            fb.addComponent(createMarkdownPane(ctx))
        }

        // Data Flow (for SAST only)
        dto.sast?.dataFlowItems?.takeIf { it.isNotEmpty() }?.let { flows -> // Corrigé
            fb.addComponent(JBLabel("Data Flow").apply {
                font = font.deriveFont(Font.BOLD, 14f)
                border = JBUI.Borders.empty(12, 0)
            })
            flows.forEachIndexed { idx, flow ->
                fb.addComponent(JBLabel("Step ${idx + 1} (${flow.type})").apply {
                    font = font.deriveFont(Font.BOLD, 12f)
                    border = JBUI.Borders.empty(4, 0)
                })
                fb.addComponent(createCodePane(flow.code.joinToString("\n") { "${it.line}: ${it.content}" }))
            }
        }

        // History
        baseVulnerability.historyItems.takeIf { it.isNotEmpty() }?.let { hist -> // Corrigé
            fb.addComponent(JBLabel("History").apply {
                font = font.deriveFont(Font.BOLD, 14f)
                border = JBUI.Borders.empty(12, 0)
            })
            hist.forEach { hi -> fb.addComponent(createMarkdownPane("**${hi.date} [${hi.type}]**: ${hi.value}")) }
        }

        // Code Snippets
        baseVulnerability.codeSnippets.takeIf { it.isNotEmpty() }?.let { snippets -> // Corrigé
            fb.addComponent(JBLabel("Code Snippets").apply {
                font = font.deriveFont(Font.BOLD, 14f)
                border = JBUI.Borders.empty(12, 0)
            })
            snippets.forEachIndexed { idx, snip ->
                fb.addComponent(JBLabel("Snippet ${idx + 1} (${snip.language})").apply {
                    font = font.deriveFont(Font.BOLD, 12f)
                    border = JBUI.Borders.empty(4, 0)
                })
                fb.addComponent(createCodePane(snip.code.joinToString("\n") { "${it.line}: ${it.content}" }))
            }
        }

        fb.addComponentFillVertically(JPanel(), 0)
        detailContainer.add(fb.panel, BorderLayout.CENTER)
        detailContainer.revalidate()
        detailContainer.repaint()
        cardLayout.show(this, "details")
    }

    private fun openFileAt(vulnerability: DetailedVulnerability) { // Signature Corrigée
        ApplicationManager.getApplication().executeOnPooledThread {
            val relativePath = vulnerability.path // Corrigé
            var vfile = project.baseDir.findFileByRelativePath(relativePath)
            if (vfile == null && project.basePath != null) {
                val abs = "${project.basePath}/$relativePath"
                vfile = LocalFileSystem.getInstance().refreshAndFindFileByPath(abs)
            }
            vfile?.let { file ->
                val desc = OpenFileDescriptor(
                    project, file,
                    vulnerability.vulnerableStartLine - 1, 0 // Corrigé
                )
                ApplicationManager.getApplication().invokeLater {
                    FileEditorManager.getInstance(project)
                        .openTextEditor(desc, true)
                        ?.markupModel
                        ?.addLineHighlighter(
                            vulnerability.vulnerableStartLine - 1, // Corrigé
                            HighlighterLayer.ERROR,
                            TextAttributes(null, null, JBColor.RED, EffectType.LINE_UNDERSCORE, Font.PLAIN)
                        )
                }
            }
        }
    }
}

private fun createMarkdownPane(markdown: String): JComponent {
    val html = markdown.replace("\n", "<br>")
    return JEditorPane("text/html", "<html><body>$html</body></html>").apply {
        isEditable = false
        isOpaque = false
        border = JBUI.Borders.empty(4)
        preferredSize = Dimension(JBUI.scale(400), -1)
    }
}

private fun createCodePane(code: String): JComponent {
    val area = JTextArea(code).apply {
        isEditable = false
        font = Font(Font.MONOSPACED, Font.PLAIN, 12)
    }
    return JBScrollPane(area).apply {
        preferredSize = Dimension(JBUI.scale(400), JBUI.scale(120))
        horizontalScrollBarPolicy = JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
    }
}

private class SeverityBadgeIcon(severity: String) : Icon {
    private val color = when (severity.uppercase()) {
        "CRITICAL" -> Color(0x8B0000)
        "HIGH" -> Color(0xDD6B20)
        "MEDIUM" -> Color(0x3182CE)
        "LOW" -> Color(0x4A5568)
        else -> Color.GRAY
    }
    private val text = severity.take(1).uppercase()
    private val size = JBUI.scale(28)
    private val font = Font("Dialog", Font.BOLD, JBUI.scale(16))
    override fun getIconWidth() = size
    override fun getIconHeight() = size
    override fun paintIcon(c: Component?, g: Graphics, x: Int, y: Int) {
        val g2 = g.create() as Graphics2D
        try {
            g2.color = color
            g2.fillOval(x, y, size, size)
            g2.font = font
            g2.color = Color.WHITE
            val fm = g2.fontMetrics
            val tx = x + (size - fm.stringWidth(text)) / 2
            val ty = y + ((size - fm.height) / 2) + fm.ascent
            g2.drawString(text, tx, ty)
        } finally {
            g2.dispose()
        }
    }
}
