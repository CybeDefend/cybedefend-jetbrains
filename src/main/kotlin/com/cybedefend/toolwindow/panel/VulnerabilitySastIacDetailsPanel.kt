// Fichier : src/main/kotlin/com/cybedefend/toolwindow/panel/VulnerabilitySastIacDetailsPanel.kt
package com.cybedefend.toolwindow.panel

import DetailedVulnerability
import GetProjectVulnerabilityByIdResponse
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.editor.markup.*
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.ui.HyperlinkLabel
import com.intellij.ui.JBColor
import com.intellij.ui.TitledSeparator
import com.intellij.ui.components.JBLabel
import com.intellij.ui.components.JBScrollPane
import com.intellij.util.ui.FormBuilder
import com.intellij.util.ui.JBUI
import java.awt.BorderLayout
import java.awt.Font
import java.nio.file.Paths
import javax.swing.JPanel
import javax.swing.event.HyperlinkEvent
import toUnified

class VulnerabilitySastIacDetailsPanel(private val project: Project) : JPanel(BorderLayout()) {

    init {
        border = JBUI.Borders.empty(16)
    }

    fun showDetails(dto: GetProjectVulnerabilityByIdResponse) {
        this.removeAll()
        val baseVulnerability =
                when {
                    dto.sast != null -> dto.sast.toUnified()
                    dto.iac != null -> dto.iac.toUnified()
                    else -> {
                        this.add(JBLabel("Invalid vulnerability data provided.", JBLabel.CENTER))
                        return
                    }
                }
        val fb = FormBuilder.createFormBuilder()
        val severityInfo =
                severityMap[baseVulnerability.currentSeverity.uppercase()]
                        ?: severityMap["UNKNOWN"]!!
        val titlePanel =
                JPanel(BorderLayout(JBUI.scale(8), 0)).apply {
                    add(
                            JBLabel(LetterCircleIcon(severityInfo.letter, severityInfo.color, 20)),
                            BorderLayout.WEST
                    )
                    add(
                            JBLabel(baseVulnerability.vulnerability.name).apply {
                                font = font.deriveFont(Font.BOLD, 20f)
                            },
                            BorderLayout.CENTER
                    )
                }
        val linkPanel =
                JPanel(BorderLayout()).apply {
                    border = JBUI.Borders.emptyLeft(28)
                    val link = HyperlinkLabel(baseVulnerability.path)
                    link.addHyperlinkListener {
                        if (it.eventType == HyperlinkEvent.EventType.ACTIVATED)
                                openFileAt(baseVulnerability)
                    }
                    add(link, BorderLayout.WEST)
                }
        fb.addComponent(titlePanel)
        fb.addComponent(linkPanel)
        fb.addVerticalGap(12)
        fb.addComponent(TitledSeparator("Description"))
        fb.addComponent(
                createMarkdownPane(
                        sanitizeMarkdownContent(baseVulnerability.vulnerability.description)
                )
        )
        baseVulnerability.vulnerability.howToPrevent.takeIf { it.isNotBlank() }?.let {
            fb.addComponent(TitledSeparator("How to Prevent"))
            fb.addComponent(createMarkdownPane(sanitizeMarkdownContent(it)))
        }
        fb.addComponent(TitledSeparator("Details"))
        val detailsPanel =
                FormBuilder.createFormBuilder()
                        .addLabeledComponent("State:", JBLabel(baseVulnerability.currentState))
                        .addLabeledComponent(
                                "Priority:",
                                JBLabel(baseVulnerability.currentPriority)
                        )
                        .panel
        fb.addComponent(detailsPanel)
        dto.sast?.dataFlowItems?.takeIf { it.isNotEmpty() }?.let { flows ->
            fb.addComponent(TitledSeparator("Data Flow"))
            val markdownContent =
                    flows.joinToString("\n\n") { flow ->
                        "**Step ${flows.indexOf(flow) + 1}: ${sanitizeText(flow.type)} in `${sanitizeText(flow.nameHighlight)}`**\n\n" +
                                "```\n" +
                                flow.code.joinToString("\n") { sanitizeText(it.content.trim()) } +
                                "\n```"
                    }
            fb.addComponent(createMarkdownPane(sanitizeMarkdownContent(markdownContent)))
        }
        baseVulnerability.historyItems.takeIf { it.isNotEmpty() }?.let { hist ->
            fb.addComponent(TitledSeparator("History"))
            val markdownContent =
                    hist.joinToString("\n") {
                        "â€¢ **${sanitizeText(it.date)}** by ${sanitizeText(it.user?.email ?: "System")}: *${sanitizeText(it.value)}*"
                    }
            fb.addComponent(createMarkdownPane(sanitizeMarkdownContent(markdownContent)))
        }

        val formPanel = fb.panel.apply { isOpaque = false }
        val scrollableWrapper =
                ScrollablePanel(BorderLayout()).apply { add(formPanel, BorderLayout.CENTER) }
        this.add(JBScrollPane(scrollableWrapper), BorderLayout.CENTER)
        this.revalidate()
        this.repaint()
    }

    private fun openFileAt(vulnerability: DetailedVulnerability) {
        ApplicationManager.getApplication().executeOnPooledThread {
            val basePath = project.basePath
            val vfile =
                    if (basePath != null) {
                        val fullPath = Paths.get(basePath, vulnerability.path).toString()
                        LocalFileSystem.getInstance().findFileByPath(fullPath)
                                ?: LocalFileSystem.getInstance().refreshAndFindFileByPath(fullPath)
                    } else {
                        null
                    }
            vfile?.let { file ->
                val line = vulnerability.vulnerableStartLine - 1
                if (line < 0) return@let
                val desc = OpenFileDescriptor(project, file, line, 0)
                ApplicationManager.getApplication().invokeLater {
                    FileEditorManager.getInstance(project)
                            .openTextEditor(desc, true)
                            ?.markupModel
                            ?.addLineHighlighter(
                                    line,
                                    HighlighterLayer.ERROR,
                                    TextAttributes(
                                            null,
                                            null,
                                            JBColor.RED,
                                            EffectType.LINE_UNDERSCORE,
                                            Font.PLAIN
                                    )
                            )
                }
            }
        }
    }

    /**
     * Sanitizes text content to prevent issues with HTML/CSS parsing. Removes or escapes
     * potentially problematic characters.
     */
    private fun sanitizeText(text: String?): String {
        return text?.let {
            it.replace("<", "&lt;")
                    .replace(">", "&gt;")
                    .replace("&", "&amp;")
                    .replace("\"", "&quot;")
                    .replace("'", "&#39;")
                    .trim()
        }
                ?: ""
    }

    /**
     * Sanitizes markdown content to prevent CSS parsing errors. Handles special characters and
     * ensures content is safe for HTML rendering.
     */
    private fun sanitizeMarkdownContent(content: String?): String {
        if (content.isNullOrBlank()) return ""

        return content.replace("\u0000", "") // Remove null characters
                .replace(
                        Regex("[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]"),
                        ""
                ) // Remove control characters
                .replace(
                        Regex("\\\\[^\\w\\s]"),
                        ""
                ) // Remove potentially problematic escape sequences
                .trim()
                .let {
                    if (it.length > 10000) it.take(10000) + "..." else it
                } // Limit content length
    }
}
