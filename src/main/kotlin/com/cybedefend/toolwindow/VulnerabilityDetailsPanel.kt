package com.cybedefend.toolwindow

import GetProjectVulnerabilityByIdResponseDto
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.ui.HyperlinkLabel
import com.intellij.ui.components.JBLabel
import com.intellij.ui.components.JBPanel
import com.intellij.ui.components.JBScrollPane
import com.intellij.util.ui.FormBuilder
import com.intellij.util.ui.JBUI
import java.awt.BorderLayout
import java.awt.CardLayout
import java.awt.FlowLayout
import java.awt.Font
import java.awt.Graphics
import java.awt.Graphics2D
import java.awt.Color
import java.awt.Component
import java.awt.Dimension
import javax.swing.*
import javax.swing.event.HyperlinkEvent

/**
 * Panel that displays vulnerability details with:
 * - Header: severity badge, title, file link on separate line
 * - Markdown-rendered descriptions
 * - Sections: Metadata, Context, History, Code Snippets
 * - No horizontal scrolling, fixed width
 */
class VulnerabilityDetailsPanel(private val project: Project) : JBPanel<VulnerabilityDetailsPanel>(BorderLayout()) {
    private val cardLayout = CardLayout()
    private val emptyPanel = JBPanel<JBPanel<*>>(BorderLayout()).apply {
        add(JBLabel("No vulnerability selected", SwingConstants.CENTER)
            .apply { font = font.deriveFont(Font.ITALIC, 14f) }, BorderLayout.CENTER)
    }
    private val detailContainer = JBPanel<JBPanel<*>>(BorderLayout()).apply {
        border = JBUI.Borders.empty(16)
    }

    init {
        layout = cardLayout
        add(emptyPanel, "empty")
        add(JBScrollPane(detailContainer).apply {
            horizontalScrollBarPolicy = JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        }, "details")
        showPlaceholder()
    }

    fun showPlaceholder() {
        cardLayout.show(this, "empty")
    }

    fun showDetails(dto: GetProjectVulnerabilityByIdResponseDto) {
        detailContainer.removeAll()

        // Header: badge + title, then file link below
        val header = JBPanel<JBPanel<*>>(BorderLayout()).apply {
            // Top row
            add(JBPanel<JBPanel<*>>(FlowLayout(FlowLayout.LEFT, 8, 0)).apply {
                add(JBLabel(SeverityBadgeIcon(dto.vulnerability.currentSeverity))).also {
                    (it as JBLabel).toolTipText = dto.vulnerability.currentSeverity
                }
                add(JBLabel(dto.vulnerability.vulnerability.name).apply {
                    font = font.deriveFont(Font.BOLD, 22f)
                    border = JBUI.Borders.emptyLeft(12)
                })
            }, BorderLayout.NORTH)
            // Bottom row: file link
            add(JBPanel<JBPanel<*>>(FlowLayout(FlowLayout.LEFT)).apply {
                add(HyperlinkLabel(dto.vulnerability.path).apply {
                    addHyperlinkListener { event ->
                        if (event.eventType == HyperlinkEvent.EventType.ACTIVATED) {
                            ApplicationManager.getApplication().executeOnPooledThread {
                                val vfile = LocalFileSystem.getInstance()
                                    .refreshAndFindFileByPath(dto.vulnerability.path)
                                if (vfile != null) {
                                    val descriptor = OpenFileDescriptor(
                                        project, vfile,
                                        dto.vulnerability.vulnerableStartLine - 1, 0
                                    )
                                    ApplicationManager.getApplication().invokeLater {
                                        FileEditorManager.getInstance(project)
                                            .openTextEditor(descriptor, true)
                                    }
                                }
                            }
                        }
                    }
                })
            }, BorderLayout.SOUTH)
            border = JBUI.Borders.emptyBottom(16)
        }
        detailContainer.add(header, BorderLayout.NORTH)

        // Content sections
        val fb = FormBuilder.createFormBuilder()

        // Description
        fb.addComponent(JLabel("Description").apply {
            font = font.deriveFont(Font.BOLD, 14f)
            border = JBUI.Borders.empty(8, 0)
        })
        fb.addComponent(createMarkdownPane(dto.vulnerability.vulnerability.description))

        // Metadata
        fb.addComponent(JLabel("Metadata").apply {
            font = font.deriveFont(Font.BOLD, 14f)
            border = JBUI.Borders.empty(12, 0)
        })
        dto.vulnerability.vulnerability.let { meta ->
            fb.addLabeledComponent("CWE:", JBLabel(meta.cwe.joinToString(", ")))
            meta.owaspTop10?.takeIf { it.isNotEmpty() }?.let {
                fb.addLabeledComponent("OWASP Top 10:", JBLabel(it.joinToString(", ")))
            }
            fb.addLabeledComponent("Type:", JBLabel(meta.vulnerabilityType))
        }

        // Context
        fb.addComponent(JLabel("Context").apply {
            font = font.deriveFont(Font.BOLD, 14f)
            border = JBUI.Borders.empty(12, 0)
        })
        fb.addComponent(createMarkdownPane(dto.vulnerability.contextualExplanation ?: ""))

        // History
        fb.addComponent(JLabel("History").apply {
            font = font.deriveFont(Font.BOLD, 14f)
            border = JBUI.Borders.empty(12, 0)
        })
        dto.vulnerability.historyItems.forEach { hi ->
            fb.addComponent(createMarkdownPane("**${hi.date} [${hi.type}]**: ${hi.value}"))
        }

        // Code Snippets
        fb.addComponent(JLabel("Code Snippets").apply {
            font = font.deriveFont(Font.BOLD, 14f)
            border = JBUI.Borders.empty(12, 0)
        })
        dto.vulnerability.codeSnippets.forEachIndexed { idx, snip ->
            fb.addComponent(JLabel("Snippet ${idx + 1} (${snip.language})").apply {
                font = font.deriveFont(Font.BOLD, 12f)
                border = JBUI.Borders.empty(4, 0)
            })
            fb.addComponent(createCodePane(snip.code.joinToString("\n") { "${it.line}: ${it.content}" }))
        }

        fb.addComponentFillVertically(JPanel(), 0)

        detailContainer.add(fb.panel, BorderLayout.CENTER)
        detailContainer.revalidate()
        detailContainer.repaint()
        cardLayout.show(this, "details")
    }

    private fun createMarkdownPane(markdown: String): JComponent {
        val html = markdown.replace("\n", "<br>")
        return JEditorPane("text/html", "<html><body>$html</body></html>").apply {
            isEditable = false
            isOpaque = false
            border = JBUI.Borders.empty(4)
            preferredSize = Dimension(JBUI.scale(400), -1)
        }
    }

    private fun createCodePane(code: String): JComponent {
        val area = JTextArea(code).apply {
            isEditable = false
            font = Font(Font.MONOSPACED, Font.PLAIN, 12)
        }
        return JBScrollPane(area).apply {
            preferredSize = Dimension(JBUI.scale(400), JBUI.scale(120))
            horizontalScrollBarPolicy = JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        }
    }

    private class SeverityBadgeIcon(severity: String) : Icon {
        private val color = when (severity.uppercase()) {
            "CRITICAL" -> Color(0x8B0000)
            "HIGH"     -> Color(0xDD6B20)
            "MEDIUM"   -> Color(0x3182CE)
            "LOW"      -> Color(0x4A5568)
            else        -> Color.GRAY
        }
        private val text = severity.take(1).uppercase()
        private val size = JBUI.scale(28)
        private val font = Font("Dialog", Font.BOLD, JBUI.scale(16))
        override fun getIconWidth() = size
        override fun getIconHeight() = size
        override fun paintIcon(c: Component?, g: Graphics, x: Int, y: Int) {
            val g2 = g.create() as Graphics2D
            try {
                g2.color = color
                g2.fillOval(x, y, size, size)
                g2.font = font
                g2.color = Color.WHITE
                val fm = g2.fontMetrics
                val tx = x + (size - fm.stringWidth(text)) / 2
                val ty = y + ((size - fm.height) / 2) + fm.ascent
                g2.drawString(text, tx, ty)
            } finally {
                g2.dispose()
            }
        }
    }
}
